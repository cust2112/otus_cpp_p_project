Тема:
----

 "Деление числового массива на две равновесные части".


Условие задачи:
--------------

Дан массив (множество) целых чисел в диапазоне [1; 10^9], длина массива от 2 до 10^5. Необходимо разделить его на два подмножества, так чтобы сумма чисел в каждом из них была одинакова.


Результаты:
----------

   - halfSumFinder - программа, решающая поставленную задачу. Принимает числа со стандартного ввода, выдает на стандартный вывод ответ: "да/нет" и номера чисел, попавших в каждое подмножество.

   - hsfTester - программа, тестирующая метод решения. Генерирует много наборов входных данных, для каждого из них вызывает алгоритм решения, выводит на экран какие-нибудь статистики: затраченое время, число рассмотрннных вариантов и т.п.

   - hsfSearchOrderDemo - программа, демонстрирующая порядок перебора вариантов решения. Показывает, что перебор происходит правильно и с малой избыточностью.

   - hsfInputGenerator - программа, генерирующая наборы входных данных. Генерирует набор входных данных и выдает его на стандартный вывод (чтобы на него можно было посмотреть и сохранить в файле).

   - hsfOutputVerifier - программа, проверяющая правильность решения. Читает из одного файла исходные данные, из другого - результат рпботы halfSumFinder'а, суммирует числа как указано и сверяет две полученные суммы.


Решение:
-------

1. Сортируем входной массив x[i], i: [0;N).

2. Находим частичные суммы sum[i] = sum (x[j]), j: [0;i].

3. Если totalSum = sum[N-1] - нечетная, то решения не существует (невозможно разделить нацело пополам).

4. Будем искать в (отсортированном) массиве частичных сумм величину desired = totalSum / 2, для этого найдем индекс ilb = lower_bound (desired).

5. Элементы отсортированного входного массива x с индексами [0;ilb] относим к 1-му подмножеству, остальные (с индексами [ilb+1;N)) - ко 2-му. Если sum[ilb] == desired, то решение найдено.

6. Иначе есть "неустойка" diff = sum[ilb] - desired, которую необходимо вычесть из 1-го подмножества. Это возможно, если x[0] <= diff <= sum[ilb-1]. В этом случае, вызываем алгоритм рекурсивно с шага 4, подставив diff в качестве desired (при этом элементы будут распределяться по подмножествам наоборот: с меньшими индексами - ко 2-му, с бОльшими - к 1-му), и надеемся, что он, в итоге, завершится на шаге 5.

7. Разделим мысленно отсортированный входной массив на две части: левую, с индексами [0;ilb-1], и правую - с индексами [ilb;N). На предыдущих шагах мы пытались для правой части, с распределением элементов: x[ilb] - в 1-м подмножестве, остальные - во 2-м, подобрать соответствующее ей распределение элементов в левой части, и у нас не получилось. Попробуем теперь сделать то же самое для других вариантов распределения элементов в правой части. Если все варианты исчерпаны (чего для больших массивов сделать практически невозможно, т.к. их 2^(N-ilb)), значит, решения не существует или, если это был рекурсивный вызов, надо вернуться на уровень вверх.


Порядок перебора
----------------

   При рассмотрении шага 7 вышеописанного алгоритма возникает вопрос: в каком порядке перебирать распределения элементов в правой части, чтобы побыстрее найти решение? Например, представив первоначальное распределение битмапом 100000... ("1" - к 1-му подмножеству, "0" - ко 2-му), можно перебирать в порядке двоичного счета: 1000..., 0100..., 1100..., 0010... и т.д. При этом получаются монотонно возрастающие (перевернутые справа налево) двоичные числа. Правда, это если каждый разряд весит больше, чем сумма всех предыдущих. А что у нас?
   Если 10^5 чисел равномерно распределены а интервале [0;10^9] и отсортированы, то среднее расстояние между двумя соседними числами 10^9 / 10^5 = 10^4, т.е., в середине массива x имеем нечто вроде: 500000000, 500010000, 500020000, 500030000 и т.д. С краю интервала (1/10 слева) имеем что-то вроде: 100000000, 100010000, 100020000, 100030000 и т.д. - т.е, разница между двумя числами, находящимися неподалеку, как правило, гораздо меньше их суммы с соседними, поэтому их выгодно перебирать по одному: 1000..., 0100..., 0010..., 0001... и т.д., а потом уже 1100...
   Однако, докуда перебирать, заранее не известно, так же как неизвестно, исходя из распределения 1010..., какое из следующих за ним дает бОльшую сумму: 1001... или 0110..., поэтому для перебора распределений в порядке возрастания "неустойки" надо использовать priority_queue, в которое, исходя из распределения 1000..., положить сначала 1100... (как ограничитель), а потом 0100..., 0010..., 0001... и т.д.

Правила перебора распределений (состояний неявного графа поиска):

1) Первое состояние всегда описывается битмапом 100000... (первый элемент интервала относим к одному множеству, остальные - к другому) и Начальным значением Номера Текущего Индекса ("curII"), равным 2, т.е. указывающим на первый слева ноль.

2) Для каждого битмапа, состоящего из расположенных рядом единиц у левого края - "11...1000..." - и с Начальным значением curII (указывающим на первый слева ноль), создаем новое состояние, добавляя в множество очередной элемент, т.е., заменяя первый слева ноль на единицу (из 1000... получаем 1100..., из 1100... получаем 1110... и т.д.) и присваивая curII Начальное значение (указывающее на первый слева ноль). При этом curII текущего состояния уменьшается на 1 (начинает указывать на первую справа единицу). Если же битмап содержит все единицы (все элементы интервала отнесены к одному из множеств) - следующего состояния не существует.

3) Для каждого состояния, содержащего битмап с произвольным набором нулей и единиц и curII, указывающий на какую-нибудь единицу, пытаемся "передвинуть" эту единицу вправо на одну позицию: из 1000... получаем 0100..., из 0100... получаем 0010... и т.д., и curII нового состояния устанавливаем на передвинутую единицу. При этом curII текущего состояния перемещаем на ближайшую единицу слева от текущей. Если передвинуть единицу вправо невозможно (она обозначает последний элемент интервала или справа от нее уже стоИт единица), ищем слева от текущей другую единицу, "подходящую". Если такой единицы не нашлось, следующего состояния не существует.

Такой порядок перебора состояний не создает избыточности. Приложение hsfSearchOrderDemo показывает порядок перебора битмапов и коэффициент избыточности, а также удостоверяет, что состояния извлекаются из priority_queue в порядке возрастания "неустойки" (т.е., порядок их генерации не нарушает это) и ни одно состояние не рассматривается дважды (при возникновении дубликатов они отбрасывались бы при добавлении в priority_queue, но от этого удалось избавиться). Группы состояний с общим предком при выводе отделяются с помощью '------------'.


Особенности реализации класса распределения элементов по подмножествам (SetImpl).
--------------------------------------------------------------------------------

   Битмапы состояний представлены разреженно, в виде набора целых чисел, первое из которых обозначает кол-во единичных элементов, а остальные - их индексы в отсортированном входном массиве. Все битмапы находятся в общем пуле (pool) - массиве целых чисел.
   Если при генерации нового состояния была передвинута вправо последняя единица, то новый объект состояния не создается, а переиспользуется текущий, сигнализируя, что из этого состояния больше порождать нечего.
   Есть также пул объектов SetImpl - для ускорения работы.